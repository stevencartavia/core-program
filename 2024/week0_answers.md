# Week 0 - The Course Primer 

### A Primer for Zero Knowledge Proofs
**🤔 Consider the following:**
1. What are Zero-Knowledge Proofs?

A zero-knowledge proof is a way of proving the validity of a statement without revealing the statement itself. The “prover” is the party trying to prove a claim, while the “verifier” is responsible for validating the claim.

2. What are the principles of soundness, completeness, and zero-knowledge?
Soundness: The Prover can only convince the Verifier if the statement is true. If the input is invalid, it is theoretically impossible to fool the zero-knowledge protocol to return “true”.
Completeness: If the input is valid, the zero-knowledge protocol always returns “true”. Hence, if the underlying statement is true, and the prover and verifier act honestly, the proof can be accepted.
Zero-Knowledge: The Verifier learns nothing about a statement beyond its validity or falsity (they have “zero-knowledge” of the statement). This requirement also prevents the verifier from deriving the original input (the statement’s content) from the proof.

3. What distinguishes interactive from non-interactive proofs?
Interactive proofs require multiple rounds of communication between the prover and verifier. Even if a verifier was convinced of a prover’s honesty, the proof would be unavailable for independent verification (computing a new proof required a new set of messages between the prover and verifier).
Non-interactive proofs, they only interact once. Where the prover and verifier have a shared key. This allows the prover to demonstrate their knowledge of some information without providing the information itself. The prover passes the secret information to a special algorithm to compute a zero-knowledge proof. This proof is sent to the verifier, who checks that the prover knows the secret information using another algorithm. Once a proof is generated, it is available for anyone else (with access to the shared key and verification algorithm) to verify.


### Topics to Research

- Fundamentals:
  - Prime Numbers and Composite Numbers
  Prime Numbers: natural numbers (positive integers greater than1) that are divisible by only 1 and the number itself. Some of the prime numbers include 2, 3, 5, 7, 11, etc.
  Composite Numbers: numbers that have more than 2 factors (divisible by more than 2 numbers). Numbers that are not prime are composite.
  ** 0 and 1 are neither prime nor composite **
  ** All even numbers except 2 are composite numbers **
  ** 4 is the smallest composite number **
  
  - Greatest Common Divisors (GCD)
  The Greatest Common Divisor (GCD) is the largest integer that divides one, two or more numbers. 
  The Euclidean Algorithm is a technique for quickly finding the GCD of two integers.
  
- Modular Arithmetic and Congruence
  - What is modular arithmetic?
  It’s the branch of arithmetic mathematics related to the “mod” functionality. It’s related to the computation of a “mod” of expressions. Numbers are reduced within a certain range, defined by the modulus. 
  - Exploring congruence classes
  The congruence class of a module n, is the set of all integers that are congruent to a module n. A ≡ B (mod C), means A and B leave the same remainder when divided by C.

- Group Theory
  - What is a group structure?
  A group is a set G equipped with an operation that combines any two elements to form a third element, in such a way that four fundamental properties are satisfied. Here’s a breakdown of what constitutes a group:
  1. Closure: If 𝑎 and 𝑏 are elements of the group, then the result of the operation 𝑎 ⋅ 𝑏 (where ⋅ denotes the group operation) must also be an element of the group.
  2. Associativity: The operation must be associative; that is, for any elements a, 𝑏, and 𝑐 in the group, ( 𝑎 ⋅ 𝑏 ) ⋅ 𝑐 = 𝑎 ⋅ ( 𝑏 ⋅ 𝑐 ).
  3. Identity Element: There must be an element e in the group such that for every element 𝑎 in the group, e ⋅ a = a ⋅ e = a. This element is called the identity element.
  4. Inverse Element: For each element a in the group, there must be an element 𝑏 (called the inverse of a) such that a⋅b=b⋅a=e, where e is the identity element.
  
  - What is a group operation?
  It’s the specific binary operation defined on the set G that satisfies the group properties. This operation is central to the group's structure and determines how elements of the set combine. The operation can vary depending on the group and can be anything from standard arithmetic operations to more abstract operations.

- Diving Deeper:
  - What is a finite group?
  It’s a group that has a finite number of elements.

  - What is a cyclic group?
  It’s a type of group that can be generated by a single element. This means there exists an element g in the group such that every element of the group can be written as gn for some integer n. If the group is finite and generated by g, it will have a finite number of elements, specifically the smallest positive integer k for which gk is the identity element of the group.

  - What is a generator?
  A generator of a group is an element from which every other element of the group can be obtained by repeatedly applying the group operation (and its inverse, if applicable). Also, a generator of a finite group is a value 𝑔 such that all elements of the group can be represented as 𝑔k for some integer 𝑘.

  - What are finite fields?
  They are cornerstones for understanding any cryptography. A finite field contains a finite number of elements and can be defined as a set of numbers that we can add, subtract, multiply and divide together and only ever end up with a result that exists in our set of numbers.

## 💪 Exercises

### Comprehension

Summarize each of the following concepts in a few sentences:

1. Three-Colouring Graph problem with Hats
The Three-Colouring Graph problem with Hats is a protocol designed to assign three different frequency bands to cellular radio towers in a network to avoid interference. The network is represented by a graph, where vertices are towers and edges indicate potential interference. The challenge is to color the graph with three colors (frequencies) such that no two adjacent vertices share the same color, a problem known to be NP-complete.

To verify the solution without revealing it, Google colors the graph and covers each vertex with a hat. The network owner can then randomly select an edge and check the colors of the connected vertices. If the vertices share the same color, Google is lying. If not, the owner repeats the process multiple times to increase confidence in the solution. This method ensures the protocol is zero-knowledge, meaning the owner learns nothing about the solution's specifics while verifying its validity.


2. Ali Baba’s Cave analogy
Peggy knows a secret word to open a magic door in a cave shaped like a ring. Victor, who is outside the cave, wants to verify that Peggy knows the word without learning the word himself.

Peggy chooses one of two paths (A or B) and Victor, after Peggy enters, randomly selects a path for her to exit from. If Peggy knows the secret word, she can always return from the path Victor names. If she doesn’t know the word, she only has a 50% chance of guessing correctly, so consistently succeeding in multiple trials would strongly suggest she knows the word.

This setup ensures Peggy’s knowledge is verified without revealing the secret word to Victor or anyone observing the process. However, if the process is recorded or if a coin flip is used visibly to choose the exit path, it could potentially expose the method or trick, making it less secure in terms of privacy.

3. The difference between interactive and non-interactive proofs
Interactive proofs involve a back-and-forth exchange between a prover and a verifier. The prover tries to convince the verifier of a statement’s truth by answering a series of questions or challenges. Non-interactive proofs, on the other hand, do not require this ongoing interaction. Instead, the prover generates a single proof that the verifier can check independently, often using a common reference string or a setup phase. Essentially, interactive proofs involve real-time communication, while non-interactive proofs are more like a one-time submission.

### Modular Arithmetic

Solve the following problems and gain a practical understanding of modular arithmetic:

1. $7\ mod\ 13$ = 7
2. $15\ mod\ 13$ = 2
3. $(7+15)\ mod\ 13$ = 9
4. $(7\ mod\ 13 + 15\ mod\ 13)\ mod\ 13$ = 9

If the results of the third and fourth calculations match, they follow a "group structure". Can you determine if these do? True

### Generators

Consider the cyclic group $(Z_{12}, +\ mod\ 12)$, commonly referred to as the "additive group of integers modulo 12". Address the following points:

1. What does the term 'generator' mean?
It’s an element that can be used to produce every element of the group through the group operation. For this cyclic group, a generator is an element that, when combined with itself (using the operation, which is addition in this case) enough times, can produce all other elements of the group.

2. Can you find a generator for this group?
The element 1 is a generator because if you add 1 to itself repeatedly (modulo 12), you get all the elements of the group.

3. Are there other generators for this group? If yes, what are they?
The elements 5, 7 and 11 are also generators.


### Implementing a Modular Arithmetic Calculator

```javascript
function modularCalculator(op, num1, num2, mod) {
    let result;

    switch (op) {
        case "+":
            result = (num1 + num2) % mod;
            break;
        case "-":
            result = (num1 - num2) % mod;
            break;
        case "*":
            result = (num1 * num2) % mod;
            break;
        default:
            throw new Error("Unsupported operation");
    }

    if (result < 0) {
        result += mod;
    }

    return result;
}

console.log(modularCalculator('+', 10, 15, 12)); // Return: 1
console.log(modularCalculator('-', 10, 15, 12)); // Return: 7
console.log(modularCalculator('*', 10, 15, 12)); // Return: 6
````
